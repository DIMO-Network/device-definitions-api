// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// DeviceDefinition is an object representing the database table.
type DeviceDefinition struct {
	ID                 string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	Model              string            `boil:"model" json:"model" toml:"model" yaml:"model"`
	Year               int16             `boil:"year" json:"year" toml:"year" yaml:"year"`
	Metadata           null.JSON         `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	CreatedAt          time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt          time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Source             null.String       `boil:"source" json:"source,omitempty" toml:"source" yaml:"source,omitempty"`
	Verified           bool              `boil:"verified" json:"verified" toml:"verified" yaml:"verified"`
	ExternalID         null.String       `boil:"external_id" json:"external_id,omitempty" toml:"external_id" yaml:"external_id,omitempty"`
	DeviceMakeID       string            `boil:"device_make_id" json:"device_make_id" toml:"device_make_id" yaml:"device_make_id"`
	ModelSlug          string            `boil:"model_slug" json:"model_slug" toml:"model_slug" yaml:"model_slug"`
	DeviceTypeID       null.String       `boil:"device_type_id" json:"device_type_id,omitempty" toml:"device_type_id" yaml:"device_type_id,omitempty"`
	ExternalIds        null.JSON         `boil:"external_ids" json:"external_ids,omitempty" toml:"external_ids" yaml:"external_ids,omitempty"`
	HardwareTemplateID null.String       `boil:"hardware_template_id" json:"hardware_template_id,omitempty" toml:"hardware_template_id" yaml:"hardware_template_id,omitempty"`
	TRXHashHex         types.StringArray `boil:"trx_hash_hex" json:"trx_hash_hex,omitempty" toml:"trx_hash_hex" yaml:"trx_hash_hex,omitempty"`
	NameSlug           string            `boil:"name_slug" json:"name_slug" toml:"name_slug" yaml:"name_slug"`

	R *deviceDefinitionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L deviceDefinitionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DeviceDefinitionColumns = struct {
	ID                 string
	Model              string
	Year               string
	Metadata           string
	CreatedAt          string
	UpdatedAt          string
	Source             string
	Verified           string
	ExternalID         string
	DeviceMakeID       string
	ModelSlug          string
	DeviceTypeID       string
	ExternalIds        string
	HardwareTemplateID string
	TRXHashHex         string
	NameSlug           string
}{
	ID:                 "id",
	Model:              "model",
	Year:               "year",
	Metadata:           "metadata",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	Source:             "source",
	Verified:           "verified",
	ExternalID:         "external_id",
	DeviceMakeID:       "device_make_id",
	ModelSlug:          "model_slug",
	DeviceTypeID:       "device_type_id",
	ExternalIds:        "external_ids",
	HardwareTemplateID: "hardware_template_id",
	TRXHashHex:         "trx_hash_hex",
	NameSlug:           "name_slug",
}

var DeviceDefinitionTableColumns = struct {
	ID                 string
	Model              string
	Year               string
	Metadata           string
	CreatedAt          string
	UpdatedAt          string
	Source             string
	Verified           string
	ExternalID         string
	DeviceMakeID       string
	ModelSlug          string
	DeviceTypeID       string
	ExternalIds        string
	HardwareTemplateID string
	TRXHashHex         string
	NameSlug           string
}{
	ID:                 "device_definitions.id",
	Model:              "device_definitions.model",
	Year:               "device_definitions.year",
	Metadata:           "device_definitions.metadata",
	CreatedAt:          "device_definitions.created_at",
	UpdatedAt:          "device_definitions.updated_at",
	Source:             "device_definitions.source",
	Verified:           "device_definitions.verified",
	ExternalID:         "device_definitions.external_id",
	DeviceMakeID:       "device_definitions.device_make_id",
	ModelSlug:          "device_definitions.model_slug",
	DeviceTypeID:       "device_definitions.device_type_id",
	ExternalIds:        "device_definitions.external_ids",
	HardwareTemplateID: "device_definitions.hardware_template_id",
	TRXHashHex:         "device_definitions.trx_hash_hex",
	NameSlug:           "device_definitions.name_slug",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod     { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) LIKE(x string) qm.QueryMod   { return qm.Where(w.field+" LIKE ?", x) }
func (w whereHelperstring) NLIKE(x string) qm.QueryMod  { return qm.Where(w.field+" NOT LIKE ?", x) }
func (w whereHelperstring) ILIKE(x string) qm.QueryMod  { return qm.Where(w.field+" ILIKE ?", x) }
func (w whereHelperstring) NILIKE(x string) qm.QueryMod { return qm.Where(w.field+" NOT ILIKE ?", x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" LIKE ?", x)
}
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT LIKE ?", x)
}
func (w whereHelpernull_String) ILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" ILIKE ?", x)
}
func (w whereHelpernull_String) NILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT ILIKE ?", x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var DeviceDefinitionWhere = struct {
	ID                 whereHelperstring
	Model              whereHelperstring
	Year               whereHelperint16
	Metadata           whereHelpernull_JSON
	CreatedAt          whereHelpertime_Time
	UpdatedAt          whereHelpertime_Time
	Source             whereHelpernull_String
	Verified           whereHelperbool
	ExternalID         whereHelpernull_String
	DeviceMakeID       whereHelperstring
	ModelSlug          whereHelperstring
	DeviceTypeID       whereHelpernull_String
	ExternalIds        whereHelpernull_JSON
	HardwareTemplateID whereHelpernull_String
	TRXHashHex         whereHelpertypes_StringArray
	NameSlug           whereHelperstring
}{
	ID:                 whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"id\""},
	Model:              whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"model\""},
	Year:               whereHelperint16{field: "\"device_definitions_api\".\"device_definitions\".\"year\""},
	Metadata:           whereHelpernull_JSON{field: "\"device_definitions_api\".\"device_definitions\".\"metadata\""},
	CreatedAt:          whereHelpertime_Time{field: "\"device_definitions_api\".\"device_definitions\".\"created_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"device_definitions_api\".\"device_definitions\".\"updated_at\""},
	Source:             whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"source\""},
	Verified:           whereHelperbool{field: "\"device_definitions_api\".\"device_definitions\".\"verified\""},
	ExternalID:         whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"external_id\""},
	DeviceMakeID:       whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"device_make_id\""},
	ModelSlug:          whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"model_slug\""},
	DeviceTypeID:       whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"device_type_id\""},
	ExternalIds:        whereHelpernull_JSON{field: "\"device_definitions_api\".\"device_definitions\".\"external_ids\""},
	HardwareTemplateID: whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"hardware_template_id\""},
	TRXHashHex:         whereHelpertypes_StringArray{field: "\"device_definitions_api\".\"device_definitions\".\"trx_hash_hex\""},
	NameSlug:           whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"name_slug\""},
}

// DeviceDefinitionRels is where relationship names are stored.
var DeviceDefinitionRels = struct {
	DeviceMake             string
	DeviceType             string
	DefinitionDeviceStyles string
	DefinitionImages       string
}{
	DeviceMake:             "DeviceMake",
	DeviceType:             "DeviceType",
	DefinitionDeviceStyles: "DefinitionDeviceStyles",
	DefinitionImages:       "DefinitionImages",
}

// deviceDefinitionR is where relationships are stored.
type deviceDefinitionR struct {
	DeviceMake             *DeviceMake      `boil:"DeviceMake" json:"DeviceMake" toml:"DeviceMake" yaml:"DeviceMake"`
	DeviceType             *DeviceType      `boil:"DeviceType" json:"DeviceType" toml:"DeviceType" yaml:"DeviceType"`
	DefinitionDeviceStyles DeviceStyleSlice `boil:"DefinitionDeviceStyles" json:"DefinitionDeviceStyles" toml:"DefinitionDeviceStyles" yaml:"DefinitionDeviceStyles"`
	DefinitionImages       ImageSlice       `boil:"DefinitionImages" json:"DefinitionImages" toml:"DefinitionImages" yaml:"DefinitionImages"`
}

// NewStruct creates a new relationship struct
func (*deviceDefinitionR) NewStruct() *deviceDefinitionR {
	return &deviceDefinitionR{}
}

func (r *deviceDefinitionR) GetDeviceMake() *DeviceMake {
	if r == nil {
		return nil
	}
	return r.DeviceMake
}

func (r *deviceDefinitionR) GetDeviceType() *DeviceType {
	if r == nil {
		return nil
	}
	return r.DeviceType
}

func (r *deviceDefinitionR) GetDefinitionDeviceStyles() DeviceStyleSlice {
	if r == nil {
		return nil
	}
	return r.DefinitionDeviceStyles
}

func (r *deviceDefinitionR) GetDefinitionImages() ImageSlice {
	if r == nil {
		return nil
	}
	return r.DefinitionImages
}

// deviceDefinitionL is where Load methods for each relationship are stored.
type deviceDefinitionL struct{}

var (
	deviceDefinitionAllColumns            = []string{"id", "model", "year", "metadata", "created_at", "updated_at", "source", "verified", "external_id", "device_make_id", "model_slug", "device_type_id", "external_ids", "hardware_template_id", "trx_hash_hex", "name_slug"}
	deviceDefinitionColumnsWithoutDefault = []string{"id", "model", "year", "device_make_id", "model_slug", "name_slug"}
	deviceDefinitionColumnsWithDefault    = []string{"metadata", "created_at", "updated_at", "source", "verified", "external_id", "device_type_id", "external_ids", "hardware_template_id", "trx_hash_hex"}
	deviceDefinitionPrimaryKeyColumns     = []string{"name_slug"}
	deviceDefinitionGeneratedColumns      = []string{}
)

type (
	// DeviceDefinitionSlice is an alias for a slice of pointers to DeviceDefinition.
	// This should almost always be used instead of []DeviceDefinition.
	DeviceDefinitionSlice []*DeviceDefinition
	// DeviceDefinitionHook is the signature for custom DeviceDefinition hook methods
	DeviceDefinitionHook func(context.Context, boil.ContextExecutor, *DeviceDefinition) error

	deviceDefinitionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	deviceDefinitionType                 = reflect.TypeOf(&DeviceDefinition{})
	deviceDefinitionMapping              = queries.MakeStructMapping(deviceDefinitionType)
	deviceDefinitionPrimaryKeyMapping, _ = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, deviceDefinitionPrimaryKeyColumns)
	deviceDefinitionInsertCacheMut       sync.RWMutex
	deviceDefinitionInsertCache          = make(map[string]insertCache)
	deviceDefinitionUpdateCacheMut       sync.RWMutex
	deviceDefinitionUpdateCache          = make(map[string]updateCache)
	deviceDefinitionUpsertCacheMut       sync.RWMutex
	deviceDefinitionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var deviceDefinitionAfterSelectMu sync.Mutex
var deviceDefinitionAfterSelectHooks []DeviceDefinitionHook

var deviceDefinitionBeforeInsertMu sync.Mutex
var deviceDefinitionBeforeInsertHooks []DeviceDefinitionHook
var deviceDefinitionAfterInsertMu sync.Mutex
var deviceDefinitionAfterInsertHooks []DeviceDefinitionHook

var deviceDefinitionBeforeUpdateMu sync.Mutex
var deviceDefinitionBeforeUpdateHooks []DeviceDefinitionHook
var deviceDefinitionAfterUpdateMu sync.Mutex
var deviceDefinitionAfterUpdateHooks []DeviceDefinitionHook

var deviceDefinitionBeforeDeleteMu sync.Mutex
var deviceDefinitionBeforeDeleteHooks []DeviceDefinitionHook
var deviceDefinitionAfterDeleteMu sync.Mutex
var deviceDefinitionAfterDeleteHooks []DeviceDefinitionHook

var deviceDefinitionBeforeUpsertMu sync.Mutex
var deviceDefinitionBeforeUpsertHooks []DeviceDefinitionHook
var deviceDefinitionAfterUpsertMu sync.Mutex
var deviceDefinitionAfterUpsertHooks []DeviceDefinitionHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DeviceDefinition) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DeviceDefinition) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DeviceDefinition) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DeviceDefinition) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DeviceDefinition) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DeviceDefinition) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DeviceDefinition) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DeviceDefinition) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DeviceDefinition) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDeviceDefinitionHook registers your hook function for all future operations.
func AddDeviceDefinitionHook(hookPoint boil.HookPoint, deviceDefinitionHook DeviceDefinitionHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		deviceDefinitionAfterSelectMu.Lock()
		deviceDefinitionAfterSelectHooks = append(deviceDefinitionAfterSelectHooks, deviceDefinitionHook)
		deviceDefinitionAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		deviceDefinitionBeforeInsertMu.Lock()
		deviceDefinitionBeforeInsertHooks = append(deviceDefinitionBeforeInsertHooks, deviceDefinitionHook)
		deviceDefinitionBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		deviceDefinitionAfterInsertMu.Lock()
		deviceDefinitionAfterInsertHooks = append(deviceDefinitionAfterInsertHooks, deviceDefinitionHook)
		deviceDefinitionAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		deviceDefinitionBeforeUpdateMu.Lock()
		deviceDefinitionBeforeUpdateHooks = append(deviceDefinitionBeforeUpdateHooks, deviceDefinitionHook)
		deviceDefinitionBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		deviceDefinitionAfterUpdateMu.Lock()
		deviceDefinitionAfterUpdateHooks = append(deviceDefinitionAfterUpdateHooks, deviceDefinitionHook)
		deviceDefinitionAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		deviceDefinitionBeforeDeleteMu.Lock()
		deviceDefinitionBeforeDeleteHooks = append(deviceDefinitionBeforeDeleteHooks, deviceDefinitionHook)
		deviceDefinitionBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		deviceDefinitionAfterDeleteMu.Lock()
		deviceDefinitionAfterDeleteHooks = append(deviceDefinitionAfterDeleteHooks, deviceDefinitionHook)
		deviceDefinitionAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		deviceDefinitionBeforeUpsertMu.Lock()
		deviceDefinitionBeforeUpsertHooks = append(deviceDefinitionBeforeUpsertHooks, deviceDefinitionHook)
		deviceDefinitionBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		deviceDefinitionAfterUpsertMu.Lock()
		deviceDefinitionAfterUpsertHooks = append(deviceDefinitionAfterUpsertHooks, deviceDefinitionHook)
		deviceDefinitionAfterUpsertMu.Unlock()
	}
}

// One returns a single deviceDefinition record from the query.
func (q deviceDefinitionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DeviceDefinition, error) {
	o := &DeviceDefinition{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for device_definitions")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DeviceDefinition records from the query.
func (q deviceDefinitionQuery) All(ctx context.Context, exec boil.ContextExecutor) (DeviceDefinitionSlice, error) {
	var o []*DeviceDefinition

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DeviceDefinition slice")
	}

	if len(deviceDefinitionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DeviceDefinition records in the query.
func (q deviceDefinitionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count device_definitions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q deviceDefinitionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if device_definitions exists")
	}

	return count > 0, nil
}

// DeviceMake pointed to by the foreign key.
func (o *DeviceDefinition) DeviceMake(mods ...qm.QueryMod) deviceMakeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DeviceMakeID),
	}

	queryMods = append(queryMods, mods...)

	return DeviceMakes(queryMods...)
}

// DeviceType pointed to by the foreign key.
func (o *DeviceDefinition) DeviceType(mods ...qm.QueryMod) deviceTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DeviceTypeID),
	}

	queryMods = append(queryMods, mods...)

	return DeviceTypes(queryMods...)
}

// DefinitionDeviceStyles retrieves all the device_style's DeviceStyles with an executor via definition_id column.
func (o *DeviceDefinition) DefinitionDeviceStyles(mods ...qm.QueryMod) deviceStyleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"device_styles\".\"definition_id\"=?", o.NameSlug),
	)

	return DeviceStyles(queryMods...)
}

// DefinitionImages retrieves all the image's Images with an executor via definition_id column.
func (o *DeviceDefinition) DefinitionImages(mods ...qm.QueryMod) imageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"images\".\"definition_id\"=?", o.NameSlug),
	)

	return Images(queryMods...)
}

// LoadDeviceMake allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deviceDefinitionL) LoadDeviceMake(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args[object.DeviceMakeID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			args[obj.DeviceMakeID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_makes`),
		qm.WhereIn(`device_definitions_api.device_makes.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DeviceMake")
	}

	var resultSlice []*DeviceMake
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DeviceMake")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for device_makes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_makes")
	}

	if len(deviceMakeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeviceMake = foreign
		if foreign.R == nil {
			foreign.R = &deviceMakeR{}
		}
		foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeviceMakeID == foreign.ID {
				local.R.DeviceMake = foreign
				if foreign.R == nil {
					foreign.R = &deviceMakeR{}
				}
				foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, local)
				break
			}
		}
	}

	return nil
}

// LoadDeviceType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deviceDefinitionL) LoadDeviceType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		if !queries.IsNil(object.DeviceTypeID) {
			args[object.DeviceTypeID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			if !queries.IsNil(obj.DeviceTypeID) {
				args[obj.DeviceTypeID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_types`),
		qm.WhereIn(`device_definitions_api.device_types.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DeviceType")
	}

	var resultSlice []*DeviceType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DeviceType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for device_types")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_types")
	}

	if len(deviceTypeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeviceType = foreign
		if foreign.R == nil {
			foreign.R = &deviceTypeR{}
		}
		foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeviceTypeID, foreign.ID) {
				local.R.DeviceType = foreign
				if foreign.R == nil {
					foreign.R = &deviceTypeR{}
				}
				foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, local)
				break
			}
		}
	}

	return nil
}

// LoadDefinitionDeviceStyles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadDefinitionDeviceStyles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args[object.NameSlug] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}
			args[obj.NameSlug] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_styles`),
		qm.WhereIn(`device_definitions_api.device_styles.definition_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load device_styles")
	}

	var resultSlice []*DeviceStyle
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice device_styles")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on device_styles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_styles")
	}

	if len(deviceStyleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DefinitionDeviceStyles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceStyleR{}
			}
			foreign.R.Definition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.NameSlug == foreign.DefinitionID {
				local.R.DefinitionDeviceStyles = append(local.R.DefinitionDeviceStyles, foreign)
				if foreign.R == nil {
					foreign.R = &deviceStyleR{}
				}
				foreign.R.Definition = local
				break
			}
		}
	}

	return nil
}

// LoadDefinitionImages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadDefinitionImages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args[object.NameSlug] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}
			args[obj.NameSlug] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`device_definitions_api.images`),
		qm.WhereIn(`device_definitions_api.images.definition_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load images")
	}

	var resultSlice []*Image
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice images")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on images")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for images")
	}

	if len(imageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DefinitionImages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &imageR{}
			}
			foreign.R.Definition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.NameSlug == foreign.DefinitionID {
				local.R.DefinitionImages = append(local.R.DefinitionImages, foreign)
				if foreign.R == nil {
					foreign.R = &imageR{}
				}
				foreign.R.Definition = local
				break
			}
		}
	}

	return nil
}

// SetDeviceMake of the deviceDefinition to the related item.
// Sets o.R.DeviceMake to related.
// Adds o to related.R.DeviceDefinitions.
func (o *DeviceDefinition) SetDeviceMake(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DeviceMake) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"device_make_id"}),
		strmangle.WhereClause("\"", "\"", 2, deviceDefinitionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.NameSlug}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeviceMakeID = related.ID
	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceMake: related,
		}
	} else {
		o.R.DeviceMake = related
	}

	if related.R == nil {
		related.R = &deviceMakeR{
			DeviceDefinitions: DeviceDefinitionSlice{o},
		}
	} else {
		related.R.DeviceDefinitions = append(related.R.DeviceDefinitions, o)
	}

	return nil
}

// SetDeviceType of the deviceDefinition to the related item.
// Sets o.R.DeviceType to related.
// Adds o to related.R.DeviceDefinitions.
func (o *DeviceDefinition) SetDeviceType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DeviceType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"device_type_id"}),
		strmangle.WhereClause("\"", "\"", 2, deviceDefinitionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.NameSlug}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeviceTypeID, related.ID)
	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceType: related,
		}
	} else {
		o.R.DeviceType = related
	}

	if related.R == nil {
		related.R = &deviceTypeR{
			DeviceDefinitions: DeviceDefinitionSlice{o},
		}
	} else {
		related.R.DeviceDefinitions = append(related.R.DeviceDefinitions, o)
	}

	return nil
}

// RemoveDeviceType relationship.
// Sets o.R.DeviceType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DeviceDefinition) RemoveDeviceType(ctx context.Context, exec boil.ContextExecutor, related *DeviceType) error {
	var err error

	queries.SetScanner(&o.DeviceTypeID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("device_type_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeviceType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeviceDefinitions {
		if queries.Equal(o.DeviceTypeID, ri.DeviceTypeID) {
			continue
		}

		ln := len(related.R.DeviceDefinitions)
		if ln > 1 && i < ln-1 {
			related.R.DeviceDefinitions[i] = related.R.DeviceDefinitions[ln-1]
		}
		related.R.DeviceDefinitions = related.R.DeviceDefinitions[:ln-1]
		break
	}
	return nil
}

// AddDefinitionDeviceStyles adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.DefinitionDeviceStyles.
// Sets related.R.Definition appropriately.
func (o *DeviceDefinition) AddDefinitionDeviceStyles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceStyle) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DefinitionID = o.NameSlug
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"device_styles\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, deviceStylePrimaryKeyColumns),
			)
			values := []interface{}{o.NameSlug, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DefinitionID = o.NameSlug
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			DefinitionDeviceStyles: related,
		}
	} else {
		o.R.DefinitionDeviceStyles = append(o.R.DefinitionDeviceStyles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceStyleR{
				Definition: o,
			}
		} else {
			rel.R.Definition = o
		}
	}
	return nil
}

// AddDefinitionImages adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.DefinitionImages.
// Sets related.R.Definition appropriately.
func (o *DeviceDefinition) AddDefinitionImages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Image) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DefinitionID = o.NameSlug
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"images\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, imagePrimaryKeyColumns),
			)
			values := []interface{}{o.NameSlug, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DefinitionID = o.NameSlug
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			DefinitionImages: related,
		}
	} else {
		o.R.DefinitionImages = append(o.R.DefinitionImages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &imageR{
				Definition: o,
			}
		} else {
			rel.R.Definition = o
		}
	}
	return nil
}

// DeviceDefinitions retrieves all the records using an executor.
func DeviceDefinitions(mods ...qm.QueryMod) deviceDefinitionQuery {
	mods = append(mods, qm.From("\"device_definitions_api\".\"device_definitions\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"device_definitions_api\".\"device_definitions\".*"})
	}

	return deviceDefinitionQuery{q}
}

// FindDeviceDefinition retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDeviceDefinition(ctx context.Context, exec boil.ContextExecutor, nameSlug string, selectCols ...string) (*DeviceDefinition, error) {
	deviceDefinitionObj := &DeviceDefinition{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"device_definitions_api\".\"device_definitions\" where \"name_slug\"=$1", sel,
	)

	q := queries.Raw(query, nameSlug)

	err := q.Bind(ctx, exec, deviceDefinitionObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from device_definitions")
	}

	if err = deviceDefinitionObj.doAfterSelectHooks(ctx, exec); err != nil {
		return deviceDefinitionObj, err
	}

	return deviceDefinitionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DeviceDefinition) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no device_definitions provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deviceDefinitionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	deviceDefinitionInsertCacheMut.RLock()
	cache, cached := deviceDefinitionInsertCache[key]
	deviceDefinitionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionColumnsWithDefault,
			deviceDefinitionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"device_definitions_api\".\"device_definitions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"device_definitions_api\".\"device_definitions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into device_definitions")
	}

	if !cached {
		deviceDefinitionInsertCacheMut.Lock()
		deviceDefinitionInsertCache[key] = cache
		deviceDefinitionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DeviceDefinition.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DeviceDefinition) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	deviceDefinitionUpdateCacheMut.RLock()
	cache, cached := deviceDefinitionUpdateCache[key]
	deviceDefinitionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update device_definitions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, deviceDefinitionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, append(wl, deviceDefinitionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update device_definitions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for device_definitions")
	}

	if !cached {
		deviceDefinitionUpdateCacheMut.Lock()
		deviceDefinitionUpdateCache[key] = cache
		deviceDefinitionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q deviceDefinitionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for device_definitions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DeviceDefinitionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, deviceDefinitionPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in deviceDefinition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all deviceDefinition")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DeviceDefinition) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no device_definitions provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deviceDefinitionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	deviceDefinitionUpsertCacheMut.RLock()
	cache, cached := deviceDefinitionUpsertCache[key]
	deviceDefinitionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionColumnsWithDefault,
			deviceDefinitionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert device_definitions, could not build update column list")
		}

		ret := strmangle.SetComplement(deviceDefinitionAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(deviceDefinitionPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert device_definitions, could not build conflict column list")
			}

			conflict = make([]string, len(deviceDefinitionPrimaryKeyColumns))
			copy(conflict, deviceDefinitionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"device_definitions_api\".\"device_definitions\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert device_definitions")
	}

	if !cached {
		deviceDefinitionUpsertCacheMut.Lock()
		deviceDefinitionUpsertCache[key] = cache
		deviceDefinitionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DeviceDefinition record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DeviceDefinition) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no DeviceDefinition provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), deviceDefinitionPrimaryKeyMapping)
	sql := "DELETE FROM \"device_definitions_api\".\"device_definitions\" WHERE \"name_slug\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for device_definitions")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q deviceDefinitionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no deviceDefinitionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for device_definitions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DeviceDefinitionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(deviceDefinitionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"device_definitions_api\".\"device_definitions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deviceDefinitionPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from deviceDefinition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for device_definitions")
	}

	if len(deviceDefinitionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DeviceDefinition) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDeviceDefinition(ctx, exec, o.NameSlug)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DeviceDefinitionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DeviceDefinitionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"device_definitions_api\".\"device_definitions\".* FROM \"device_definitions_api\".\"device_definitions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deviceDefinitionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DeviceDefinitionSlice")
	}

	*o = slice

	return nil
}

// DeviceDefinitionExists checks if the DeviceDefinition row exists.
func DeviceDefinitionExists(ctx context.Context, exec boil.ContextExecutor, nameSlug string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"device_definitions_api\".\"device_definitions\" where \"name_slug\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, nameSlug)
	}
	row := exec.QueryRowContext(ctx, sql, nameSlug)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if device_definitions exists")
	}

	return exists, nil
}

// Exists checks if the DeviceDefinition row exists.
func (o *DeviceDefinition) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DeviceDefinitionExists(ctx, exec, o.NameSlug)
}
