// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DeviceDefinition is an object representing the database table.
type DeviceDefinition struct {
	ID                 string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Model              string      `boil:"model" json:"model" toml:"model" yaml:"model"`
	Year               int16       `boil:"year" json:"year" toml:"year" yaml:"year"`
	Metadata           null.JSON   `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	CreatedAt          time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt          time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Source             null.String `boil:"source" json:"source,omitempty" toml:"source" yaml:"source,omitempty"`
	Verified           bool        `boil:"verified" json:"verified" toml:"verified" yaml:"verified"`
	ExternalID         null.String `boil:"external_id" json:"external_id,omitempty" toml:"external_id" yaml:"external_id,omitempty"`
	DeviceMakeID       string      `boil:"device_make_id" json:"device_make_id" toml:"device_make_id" yaml:"device_make_id"`
	ModelSlug          string      `boil:"model_slug" json:"model_slug" toml:"model_slug" yaml:"model_slug"`
	DeviceTypeID       null.String `boil:"device_type_id" json:"device_type_id,omitempty" toml:"device_type_id" yaml:"device_type_id,omitempty"`
	ExternalIds        null.JSON   `boil:"external_ids" json:"external_ids,omitempty" toml:"external_ids" yaml:"external_ids,omitempty"`
	HardwareTemplateID null.String `boil:"hardware_template_id" json:"hardware_template_id,omitempty" toml:"hardware_template_id" yaml:"hardware_template_id,omitempty"`
	TRXHashHex         null.String `boil:"trx_hash_hex" json:"trx_hash_hex,omitempty" toml:"trx_hash_hex" yaml:"trx_hash_hex,omitempty"`
	NameSlug           null.String `boil:"name_slug" json:"name_slug,omitempty" toml:"name_slug" yaml:"name_slug,omitempty"`

	R *deviceDefinitionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L deviceDefinitionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DeviceDefinitionColumns = struct {
	ID                 string
	Model              string
	Year               string
	Metadata           string
	CreatedAt          string
	UpdatedAt          string
	Source             string
	Verified           string
	ExternalID         string
	DeviceMakeID       string
	ModelSlug          string
	DeviceTypeID       string
	ExternalIds        string
	HardwareTemplateID string
	TRXHashHex         string
	NameSlug           string
}{
	ID:                 "id",
	Model:              "model",
	Year:               "year",
	Metadata:           "metadata",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	Source:             "source",
	Verified:           "verified",
	ExternalID:         "external_id",
	DeviceMakeID:       "device_make_id",
	ModelSlug:          "model_slug",
	DeviceTypeID:       "device_type_id",
	ExternalIds:        "external_ids",
	HardwareTemplateID: "hardware_template_id",
	TRXHashHex:         "trx_hash_hex",
	NameSlug:           "name_slug",
}

var DeviceDefinitionTableColumns = struct {
	ID                 string
	Model              string
	Year               string
	Metadata           string
	CreatedAt          string
	UpdatedAt          string
	Source             string
	Verified           string
	ExternalID         string
	DeviceMakeID       string
	ModelSlug          string
	DeviceTypeID       string
	ExternalIds        string
	HardwareTemplateID string
	TRXHashHex         string
	NameSlug           string
}{
	ID:                 "device_definitions.id",
	Model:              "device_definitions.model",
	Year:               "device_definitions.year",
	Metadata:           "device_definitions.metadata",
	CreatedAt:          "device_definitions.created_at",
	UpdatedAt:          "device_definitions.updated_at",
	Source:             "device_definitions.source",
	Verified:           "device_definitions.verified",
	ExternalID:         "device_definitions.external_id",
	DeviceMakeID:       "device_definitions.device_make_id",
	ModelSlug:          "device_definitions.model_slug",
	DeviceTypeID:       "device_definitions.device_type_id",
	ExternalIds:        "device_definitions.external_ids",
	HardwareTemplateID: "device_definitions.hardware_template_id",
	TRXHashHex:         "device_definitions.trx_hash_hex",
	NameSlug:           "device_definitions.name_slug",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var DeviceDefinitionWhere = struct {
	ID                 whereHelperstring
	Model              whereHelperstring
	Year               whereHelperint16
	Metadata           whereHelpernull_JSON
	CreatedAt          whereHelpertime_Time
	UpdatedAt          whereHelpertime_Time
	Source             whereHelpernull_String
	Verified           whereHelperbool
	ExternalID         whereHelpernull_String
	DeviceMakeID       whereHelperstring
	ModelSlug          whereHelperstring
	DeviceTypeID       whereHelpernull_String
	ExternalIds        whereHelpernull_JSON
	HardwareTemplateID whereHelpernull_String
	TRXHashHex         whereHelpernull_String
	NameSlug           whereHelpernull_String
}{
	ID:                 whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"id\""},
	Model:              whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"model\""},
	Year:               whereHelperint16{field: "\"device_definitions_api\".\"device_definitions\".\"year\""},
	Metadata:           whereHelpernull_JSON{field: "\"device_definitions_api\".\"device_definitions\".\"metadata\""},
	CreatedAt:          whereHelpertime_Time{field: "\"device_definitions_api\".\"device_definitions\".\"created_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"device_definitions_api\".\"device_definitions\".\"updated_at\""},
	Source:             whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"source\""},
	Verified:           whereHelperbool{field: "\"device_definitions_api\".\"device_definitions\".\"verified\""},
	ExternalID:         whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"external_id\""},
	DeviceMakeID:       whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"device_make_id\""},
	ModelSlug:          whereHelperstring{field: "\"device_definitions_api\".\"device_definitions\".\"model_slug\""},
	DeviceTypeID:       whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"device_type_id\""},
	ExternalIds:        whereHelpernull_JSON{field: "\"device_definitions_api\".\"device_definitions\".\"external_ids\""},
	HardwareTemplateID: whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"hardware_template_id\""},
	TRXHashHex:         whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"trx_hash_hex\""},
	NameSlug:           whereHelpernull_String{field: "\"device_definitions_api\".\"device_definitions\".\"name_slug\""},
}

// DeviceDefinitionRels is where relationship names are stored.
var DeviceDefinitionRels = struct {
	DeviceMake         string
	DeviceType         string
	DeviceIntegrations string
	DeviceNhtsaRecalls string
	DeviceStyles       string
	Images             string
	Reviews            string
	VinNumbers         string
}{
	DeviceMake:         "DeviceMake",
	DeviceType:         "DeviceType",
	DeviceIntegrations: "DeviceIntegrations",
	DeviceNhtsaRecalls: "DeviceNhtsaRecalls",
	DeviceStyles:       "DeviceStyles",
	Images:             "Images",
	Reviews:            "Reviews",
	VinNumbers:         "VinNumbers",
}

// deviceDefinitionR is where relationships are stored.
type deviceDefinitionR struct {
	DeviceMake         *DeviceMake            `boil:"DeviceMake" json:"DeviceMake" toml:"DeviceMake" yaml:"DeviceMake"`
	DeviceType         *DeviceType            `boil:"DeviceType" json:"DeviceType" toml:"DeviceType" yaml:"DeviceType"`
	DeviceIntegrations DeviceIntegrationSlice `boil:"DeviceIntegrations" json:"DeviceIntegrations" toml:"DeviceIntegrations" yaml:"DeviceIntegrations"`
	DeviceNhtsaRecalls DeviceNhtsaRecallSlice `boil:"DeviceNhtsaRecalls" json:"DeviceNhtsaRecalls" toml:"DeviceNhtsaRecalls" yaml:"DeviceNhtsaRecalls"`
	DeviceStyles       DeviceStyleSlice       `boil:"DeviceStyles" json:"DeviceStyles" toml:"DeviceStyles" yaml:"DeviceStyles"`
	Images             ImageSlice             `boil:"Images" json:"Images" toml:"Images" yaml:"Images"`
	Reviews            ReviewSlice            `boil:"Reviews" json:"Reviews" toml:"Reviews" yaml:"Reviews"`
	VinNumbers         VinNumberSlice         `boil:"VinNumbers" json:"VinNumbers" toml:"VinNumbers" yaml:"VinNumbers"`
}

// NewStruct creates a new relationship struct
func (*deviceDefinitionR) NewStruct() *deviceDefinitionR {
	return &deviceDefinitionR{}
}

func (r *deviceDefinitionR) GetDeviceMake() *DeviceMake {
	if r == nil {
		return nil
	}
	return r.DeviceMake
}

func (r *deviceDefinitionR) GetDeviceType() *DeviceType {
	if r == nil {
		return nil
	}
	return r.DeviceType
}

func (r *deviceDefinitionR) GetDeviceIntegrations() DeviceIntegrationSlice {
	if r == nil {
		return nil
	}
	return r.DeviceIntegrations
}

func (r *deviceDefinitionR) GetDeviceNhtsaRecalls() DeviceNhtsaRecallSlice {
	if r == nil {
		return nil
	}
	return r.DeviceNhtsaRecalls
}

func (r *deviceDefinitionR) GetDeviceStyles() DeviceStyleSlice {
	if r == nil {
		return nil
	}
	return r.DeviceStyles
}

func (r *deviceDefinitionR) GetImages() ImageSlice {
	if r == nil {
		return nil
	}
	return r.Images
}

func (r *deviceDefinitionR) GetReviews() ReviewSlice {
	if r == nil {
		return nil
	}
	return r.Reviews
}

func (r *deviceDefinitionR) GetVinNumbers() VinNumberSlice {
	if r == nil {
		return nil
	}
	return r.VinNumbers
}

// deviceDefinitionL is where Load methods for each relationship are stored.
type deviceDefinitionL struct{}

var (
	deviceDefinitionAllColumns            = []string{"id", "model", "year", "metadata", "created_at", "updated_at", "source", "verified", "external_id", "device_make_id", "model_slug", "device_type_id", "external_ids", "hardware_template_id", "trx_hash_hex", "name_slug"}
	deviceDefinitionColumnsWithoutDefault = []string{"id", "model", "year", "device_make_id", "model_slug"}
	deviceDefinitionColumnsWithDefault    = []string{"metadata", "created_at", "updated_at", "source", "verified", "external_id", "device_type_id", "external_ids", "hardware_template_id", "trx_hash_hex", "name_slug"}
	deviceDefinitionPrimaryKeyColumns     = []string{"id"}
	deviceDefinitionGeneratedColumns      = []string{}
)

type (
	// DeviceDefinitionSlice is an alias for a slice of pointers to DeviceDefinition.
	// This should almost always be used instead of []DeviceDefinition.
	DeviceDefinitionSlice []*DeviceDefinition
	// DeviceDefinitionHook is the signature for custom DeviceDefinition hook methods
	DeviceDefinitionHook func(context.Context, boil.ContextExecutor, *DeviceDefinition) error

	deviceDefinitionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	deviceDefinitionType                 = reflect.TypeOf(&DeviceDefinition{})
	deviceDefinitionMapping              = queries.MakeStructMapping(deviceDefinitionType)
	deviceDefinitionPrimaryKeyMapping, _ = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, deviceDefinitionPrimaryKeyColumns)
	deviceDefinitionInsertCacheMut       sync.RWMutex
	deviceDefinitionInsertCache          = make(map[string]insertCache)
	deviceDefinitionUpdateCacheMut       sync.RWMutex
	deviceDefinitionUpdateCache          = make(map[string]updateCache)
	deviceDefinitionUpsertCacheMut       sync.RWMutex
	deviceDefinitionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var deviceDefinitionAfterSelectHooks []DeviceDefinitionHook

var deviceDefinitionBeforeInsertHooks []DeviceDefinitionHook
var deviceDefinitionAfterInsertHooks []DeviceDefinitionHook

var deviceDefinitionBeforeUpdateHooks []DeviceDefinitionHook
var deviceDefinitionAfterUpdateHooks []DeviceDefinitionHook

var deviceDefinitionBeforeDeleteHooks []DeviceDefinitionHook
var deviceDefinitionAfterDeleteHooks []DeviceDefinitionHook

var deviceDefinitionBeforeUpsertHooks []DeviceDefinitionHook
var deviceDefinitionAfterUpsertHooks []DeviceDefinitionHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DeviceDefinition) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DeviceDefinition) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DeviceDefinition) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DeviceDefinition) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DeviceDefinition) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DeviceDefinition) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DeviceDefinition) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DeviceDefinition) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DeviceDefinition) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range deviceDefinitionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDeviceDefinitionHook registers your hook function for all future operations.
func AddDeviceDefinitionHook(hookPoint boil.HookPoint, deviceDefinitionHook DeviceDefinitionHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		deviceDefinitionAfterSelectHooks = append(deviceDefinitionAfterSelectHooks, deviceDefinitionHook)
	case boil.BeforeInsertHook:
		deviceDefinitionBeforeInsertHooks = append(deviceDefinitionBeforeInsertHooks, deviceDefinitionHook)
	case boil.AfterInsertHook:
		deviceDefinitionAfterInsertHooks = append(deviceDefinitionAfterInsertHooks, deviceDefinitionHook)
	case boil.BeforeUpdateHook:
		deviceDefinitionBeforeUpdateHooks = append(deviceDefinitionBeforeUpdateHooks, deviceDefinitionHook)
	case boil.AfterUpdateHook:
		deviceDefinitionAfterUpdateHooks = append(deviceDefinitionAfterUpdateHooks, deviceDefinitionHook)
	case boil.BeforeDeleteHook:
		deviceDefinitionBeforeDeleteHooks = append(deviceDefinitionBeforeDeleteHooks, deviceDefinitionHook)
	case boil.AfterDeleteHook:
		deviceDefinitionAfterDeleteHooks = append(deviceDefinitionAfterDeleteHooks, deviceDefinitionHook)
	case boil.BeforeUpsertHook:
		deviceDefinitionBeforeUpsertHooks = append(deviceDefinitionBeforeUpsertHooks, deviceDefinitionHook)
	case boil.AfterUpsertHook:
		deviceDefinitionAfterUpsertHooks = append(deviceDefinitionAfterUpsertHooks, deviceDefinitionHook)
	}
}

// One returns a single deviceDefinition record from the query.
func (q deviceDefinitionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DeviceDefinition, error) {
	o := &DeviceDefinition{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for device_definitions")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DeviceDefinition records from the query.
func (q deviceDefinitionQuery) All(ctx context.Context, exec boil.ContextExecutor) (DeviceDefinitionSlice, error) {
	var o []*DeviceDefinition

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DeviceDefinition slice")
	}

	if len(deviceDefinitionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DeviceDefinition records in the query.
func (q deviceDefinitionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count device_definitions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q deviceDefinitionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if device_definitions exists")
	}

	return count > 0, nil
}

// DeviceMake pointed to by the foreign key.
func (o *DeviceDefinition) DeviceMake(mods ...qm.QueryMod) deviceMakeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DeviceMakeID),
	}

	queryMods = append(queryMods, mods...)

	return DeviceMakes(queryMods...)
}

// DeviceType pointed to by the foreign key.
func (o *DeviceDefinition) DeviceType(mods ...qm.QueryMod) deviceTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DeviceTypeID),
	}

	queryMods = append(queryMods, mods...)

	return DeviceTypes(queryMods...)
}

// DeviceIntegrations retrieves all the device_integration's DeviceIntegrations with an executor.
func (o *DeviceDefinition) DeviceIntegrations(mods ...qm.QueryMod) deviceIntegrationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"device_integrations\".\"device_definition_id\"=?", o.ID),
	)

	return DeviceIntegrations(queryMods...)
}

// DeviceNhtsaRecalls retrieves all the device_nhtsa_recall's DeviceNhtsaRecalls with an executor.
func (o *DeviceDefinition) DeviceNhtsaRecalls(mods ...qm.QueryMod) deviceNhtsaRecallQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"device_nhtsa_recalls\".\"device_definition_id\"=?", o.ID),
	)

	return DeviceNhtsaRecalls(queryMods...)
}

// DeviceStyles retrieves all the device_style's DeviceStyles with an executor.
func (o *DeviceDefinition) DeviceStyles(mods ...qm.QueryMod) deviceStyleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"device_styles\".\"device_definition_id\"=?", o.ID),
	)

	return DeviceStyles(queryMods...)
}

// Images retrieves all the image's Images with an executor.
func (o *DeviceDefinition) Images(mods ...qm.QueryMod) imageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"images\".\"device_definition_id\"=?", o.ID),
	)

	return Images(queryMods...)
}

// Reviews retrieves all the review's Reviews with an executor.
func (o *DeviceDefinition) Reviews(mods ...qm.QueryMod) reviewQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"reviews\".\"device_definition_id\"=?", o.ID),
	)

	return Reviews(queryMods...)
}

// VinNumbers retrieves all the vin_number's VinNumbers with an executor.
func (o *DeviceDefinition) VinNumbers(mods ...qm.QueryMod) vinNumberQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"device_definitions_api\".\"vin_numbers\".\"device_definition_id\"=?", o.ID),
	)

	return VinNumbers(queryMods...)
}

// LoadDeviceMake allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deviceDefinitionL) LoadDeviceMake(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.DeviceMakeID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.DeviceMakeID {
					continue Outer
				}
			}

			args = append(args, obj.DeviceMakeID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_makes`),
		qm.WhereIn(`device_definitions_api.device_makes.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DeviceMake")
	}

	var resultSlice []*DeviceMake
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DeviceMake")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for device_makes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_makes")
	}

	if len(deviceDefinitionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeviceMake = foreign
		if foreign.R == nil {
			foreign.R = &deviceMakeR{}
		}
		foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeviceMakeID == foreign.ID {
				local.R.DeviceMake = foreign
				if foreign.R == nil {
					foreign.R = &deviceMakeR{}
				}
				foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, local)
				break
			}
		}
	}

	return nil
}

// LoadDeviceType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (deviceDefinitionL) LoadDeviceType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		if !queries.IsNil(object.DeviceTypeID) {
			args = append(args, object.DeviceTypeID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeviceTypeID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeviceTypeID) {
				args = append(args, obj.DeviceTypeID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_types`),
		qm.WhereIn(`device_definitions_api.device_types.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DeviceType")
	}

	var resultSlice []*DeviceType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DeviceType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for device_types")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_types")
	}

	if len(deviceDefinitionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeviceType = foreign
		if foreign.R == nil {
			foreign.R = &deviceTypeR{}
		}
		foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeviceTypeID, foreign.ID) {
				local.R.DeviceType = foreign
				if foreign.R == nil {
					foreign.R = &deviceTypeR{}
				}
				foreign.R.DeviceDefinitions = append(foreign.R.DeviceDefinitions, local)
				break
			}
		}
	}

	return nil
}

// LoadDeviceIntegrations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadDeviceIntegrations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_integrations`),
		qm.WhereIn(`device_definitions_api.device_integrations.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load device_integrations")
	}

	var resultSlice []*DeviceIntegration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice device_integrations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on device_integrations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_integrations")
	}

	if len(deviceIntegrationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeviceIntegrations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceIntegrationR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DeviceDefinitionID {
				local.R.DeviceIntegrations = append(local.R.DeviceIntegrations, foreign)
				if foreign.R == nil {
					foreign.R = &deviceIntegrationR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// LoadDeviceNhtsaRecalls allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadDeviceNhtsaRecalls(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_nhtsa_recalls`),
		qm.WhereIn(`device_definitions_api.device_nhtsa_recalls.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load device_nhtsa_recalls")
	}

	var resultSlice []*DeviceNhtsaRecall
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice device_nhtsa_recalls")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on device_nhtsa_recalls")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_nhtsa_recalls")
	}

	if len(deviceNhtsaRecallAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeviceNhtsaRecalls = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceNhtsaRecallR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.DeviceDefinitionID) {
				local.R.DeviceNhtsaRecalls = append(local.R.DeviceNhtsaRecalls, foreign)
				if foreign.R == nil {
					foreign.R = &deviceNhtsaRecallR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// LoadDeviceStyles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadDeviceStyles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.device_styles`),
		qm.WhereIn(`device_definitions_api.device_styles.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load device_styles")
	}

	var resultSlice []*DeviceStyle
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice device_styles")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on device_styles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for device_styles")
	}

	if len(deviceStyleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DeviceStyles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceStyleR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DeviceDefinitionID {
				local.R.DeviceStyles = append(local.R.DeviceStyles, foreign)
				if foreign.R == nil {
					foreign.R = &deviceStyleR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// LoadImages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadImages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.images`),
		qm.WhereIn(`device_definitions_api.images.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load images")
	}

	var resultSlice []*Image
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice images")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on images")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for images")
	}

	if len(imageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Images = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &imageR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DeviceDefinitionID {
				local.R.Images = append(local.R.Images, foreign)
				if foreign.R == nil {
					foreign.R = &imageR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// LoadReviews allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadReviews(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.reviews`),
		qm.WhereIn(`device_definitions_api.reviews.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load reviews")
	}

	var resultSlice []*Review
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice reviews")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on reviews")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for reviews")
	}

	if len(reviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Reviews = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &reviewR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DeviceDefinitionID {
				local.R.Reviews = append(local.R.Reviews, foreign)
				if foreign.R == nil {
					foreign.R = &reviewR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// LoadVinNumbers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (deviceDefinitionL) LoadVinNumbers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDeviceDefinition interface{}, mods queries.Applicator) error {
	var slice []*DeviceDefinition
	var object *DeviceDefinition

	if singular {
		var ok bool
		object, ok = maybeDeviceDefinition.(*DeviceDefinition)
		if !ok {
			object = new(DeviceDefinition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDeviceDefinition))
			}
		}
	} else {
		s, ok := maybeDeviceDefinition.(*[]*DeviceDefinition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDeviceDefinition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDeviceDefinition))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &deviceDefinitionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &deviceDefinitionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`device_definitions_api.vin_numbers`),
		qm.WhereIn(`device_definitions_api.vin_numbers.device_definition_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load vin_numbers")
	}

	var resultSlice []*VinNumber
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice vin_numbers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on vin_numbers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for vin_numbers")
	}

	if len(vinNumberAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VinNumbers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &vinNumberR{}
			}
			foreign.R.DeviceDefinition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DeviceDefinitionID {
				local.R.VinNumbers = append(local.R.VinNumbers, foreign)
				if foreign.R == nil {
					foreign.R = &vinNumberR{}
				}
				foreign.R.DeviceDefinition = local
				break
			}
		}
	}

	return nil
}

// SetDeviceMake of the deviceDefinition to the related item.
// Sets o.R.DeviceMake to related.
// Adds o to related.R.DeviceDefinitions.
func (o *DeviceDefinition) SetDeviceMake(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DeviceMake) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"device_make_id"}),
		strmangle.WhereClause("\"", "\"", 2, deviceDefinitionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeviceMakeID = related.ID
	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceMake: related,
		}
	} else {
		o.R.DeviceMake = related
	}

	if related.R == nil {
		related.R = &deviceMakeR{
			DeviceDefinitions: DeviceDefinitionSlice{o},
		}
	} else {
		related.R.DeviceDefinitions = append(related.R.DeviceDefinitions, o)
	}

	return nil
}

// SetDeviceType of the deviceDefinition to the related item.
// Sets o.R.DeviceType to related.
// Adds o to related.R.DeviceDefinitions.
func (o *DeviceDefinition) SetDeviceType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DeviceType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"device_type_id"}),
		strmangle.WhereClause("\"", "\"", 2, deviceDefinitionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeviceTypeID, related.ID)
	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceType: related,
		}
	} else {
		o.R.DeviceType = related
	}

	if related.R == nil {
		related.R = &deviceTypeR{
			DeviceDefinitions: DeviceDefinitionSlice{o},
		}
	} else {
		related.R.DeviceDefinitions = append(related.R.DeviceDefinitions, o)
	}

	return nil
}

// RemoveDeviceType relationship.
// Sets o.R.DeviceType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DeviceDefinition) RemoveDeviceType(ctx context.Context, exec boil.ContextExecutor, related *DeviceType) error {
	var err error

	queries.SetScanner(&o.DeviceTypeID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("device_type_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeviceType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeviceDefinitions {
		if queries.Equal(o.DeviceTypeID, ri.DeviceTypeID) {
			continue
		}

		ln := len(related.R.DeviceDefinitions)
		if ln > 1 && i < ln-1 {
			related.R.DeviceDefinitions[i] = related.R.DeviceDefinitions[ln-1]
		}
		related.R.DeviceDefinitions = related.R.DeviceDefinitions[:ln-1]
		break
	}
	return nil
}

// AddDeviceIntegrations adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.DeviceIntegrations.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddDeviceIntegrations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceIntegration) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeviceDefinitionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"device_integrations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, deviceIntegrationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.DeviceDefinitionID, rel.IntegrationID, rel.Region}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeviceDefinitionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceIntegrations: related,
		}
	} else {
		o.R.DeviceIntegrations = append(o.R.DeviceIntegrations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceIntegrationR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// AddDeviceNhtsaRecalls adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.DeviceNhtsaRecalls.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddDeviceNhtsaRecalls(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceNhtsaRecall) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.DeviceDefinitionID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"device_nhtsa_recalls\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, deviceNhtsaRecallPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.DeviceDefinitionID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceNhtsaRecalls: related,
		}
	} else {
		o.R.DeviceNhtsaRecalls = append(o.R.DeviceNhtsaRecalls, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceNhtsaRecallR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// SetDeviceNhtsaRecalls removes all previously related items of the
// device_definition replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.DeviceDefinition's DeviceNhtsaRecalls accordingly.
// Replaces o.R.DeviceNhtsaRecalls with related.
// Sets related.R.DeviceDefinition's DeviceNhtsaRecalls accordingly.
func (o *DeviceDefinition) SetDeviceNhtsaRecalls(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceNhtsaRecall) error {
	query := "update \"device_definitions_api\".\"device_nhtsa_recalls\" set \"device_definition_id\" = null where \"device_definition_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.DeviceNhtsaRecalls {
			queries.SetScanner(&rel.DeviceDefinitionID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.DeviceDefinition = nil
		}
		o.R.DeviceNhtsaRecalls = nil
	}

	return o.AddDeviceNhtsaRecalls(ctx, exec, insert, related...)
}

// RemoveDeviceNhtsaRecalls relationships from objects passed in.
// Removes related items from R.DeviceNhtsaRecalls (uses pointer comparison, removal does not keep order)
// Sets related.R.DeviceDefinition.
func (o *DeviceDefinition) RemoveDeviceNhtsaRecalls(ctx context.Context, exec boil.ContextExecutor, related ...*DeviceNhtsaRecall) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.DeviceDefinitionID, nil)
		if rel.R != nil {
			rel.R.DeviceDefinition = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("device_definition_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.DeviceNhtsaRecalls {
			if rel != ri {
				continue
			}

			ln := len(o.R.DeviceNhtsaRecalls)
			if ln > 1 && i < ln-1 {
				o.R.DeviceNhtsaRecalls[i] = o.R.DeviceNhtsaRecalls[ln-1]
			}
			o.R.DeviceNhtsaRecalls = o.R.DeviceNhtsaRecalls[:ln-1]
			break
		}
	}

	return nil
}

// AddDeviceStyles adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.DeviceStyles.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddDeviceStyles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeviceStyle) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeviceDefinitionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"device_styles\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, deviceStylePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeviceDefinitionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			DeviceStyles: related,
		}
	} else {
		o.R.DeviceStyles = append(o.R.DeviceStyles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceStyleR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// AddImages adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.Images.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddImages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Image) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeviceDefinitionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"images\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, imagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeviceDefinitionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			Images: related,
		}
	} else {
		o.R.Images = append(o.R.Images, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &imageR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// AddReviews adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.Reviews.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddReviews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Review) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeviceDefinitionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"reviews\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, reviewPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeviceDefinitionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			Reviews: related,
		}
	} else {
		o.R.Reviews = append(o.R.Reviews, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &reviewR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// AddVinNumbers adds the given related objects to the existing relationships
// of the device_definition, optionally inserting them as new records.
// Appends related to o.R.VinNumbers.
// Sets related.R.DeviceDefinition appropriately.
func (o *DeviceDefinition) AddVinNumbers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VinNumber) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeviceDefinitionID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"device_definitions_api\".\"vin_numbers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"device_definition_id"}),
				strmangle.WhereClause("\"", "\"", 2, vinNumberPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Vin}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeviceDefinitionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &deviceDefinitionR{
			VinNumbers: related,
		}
	} else {
		o.R.VinNumbers = append(o.R.VinNumbers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &vinNumberR{
				DeviceDefinition: o,
			}
		} else {
			rel.R.DeviceDefinition = o
		}
	}
	return nil
}

// DeviceDefinitions retrieves all the records using an executor.
func DeviceDefinitions(mods ...qm.QueryMod) deviceDefinitionQuery {
	mods = append(mods, qm.From("\"device_definitions_api\".\"device_definitions\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"device_definitions_api\".\"device_definitions\".*"})
	}

	return deviceDefinitionQuery{q}
}

// FindDeviceDefinition retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDeviceDefinition(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*DeviceDefinition, error) {
	deviceDefinitionObj := &DeviceDefinition{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"device_definitions_api\".\"device_definitions\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, deviceDefinitionObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from device_definitions")
	}

	if err = deviceDefinitionObj.doAfterSelectHooks(ctx, exec); err != nil {
		return deviceDefinitionObj, err
	}

	return deviceDefinitionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DeviceDefinition) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no device_definitions provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deviceDefinitionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	deviceDefinitionInsertCacheMut.RLock()
	cache, cached := deviceDefinitionInsertCache[key]
	deviceDefinitionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionColumnsWithDefault,
			deviceDefinitionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"device_definitions_api\".\"device_definitions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"device_definitions_api\".\"device_definitions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into device_definitions")
	}

	if !cached {
		deviceDefinitionInsertCacheMut.Lock()
		deviceDefinitionInsertCache[key] = cache
		deviceDefinitionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DeviceDefinition.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DeviceDefinition) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	deviceDefinitionUpdateCacheMut.RLock()
	cache, cached := deviceDefinitionUpdateCache[key]
	deviceDefinitionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update device_definitions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, deviceDefinitionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, append(wl, deviceDefinitionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update device_definitions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for device_definitions")
	}

	if !cached {
		deviceDefinitionUpdateCacheMut.Lock()
		deviceDefinitionUpdateCache[key] = cache
		deviceDefinitionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q deviceDefinitionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for device_definitions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DeviceDefinitionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"device_definitions_api\".\"device_definitions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, deviceDefinitionPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in deviceDefinition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all deviceDefinition")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DeviceDefinition) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no device_definitions provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(deviceDefinitionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	deviceDefinitionUpsertCacheMut.RLock()
	cache, cached := deviceDefinitionUpsertCache[key]
	deviceDefinitionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionColumnsWithDefault,
			deviceDefinitionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			deviceDefinitionAllColumns,
			deviceDefinitionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert device_definitions, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(deviceDefinitionPrimaryKeyColumns))
			copy(conflict, deviceDefinitionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"device_definitions_api\".\"device_definitions\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(deviceDefinitionType, deviceDefinitionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert device_definitions")
	}

	if !cached {
		deviceDefinitionUpsertCacheMut.Lock()
		deviceDefinitionUpsertCache[key] = cache
		deviceDefinitionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DeviceDefinition record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DeviceDefinition) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no DeviceDefinition provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), deviceDefinitionPrimaryKeyMapping)
	sql := "DELETE FROM \"device_definitions_api\".\"device_definitions\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for device_definitions")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q deviceDefinitionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no deviceDefinitionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from device_definitions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for device_definitions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DeviceDefinitionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(deviceDefinitionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"device_definitions_api\".\"device_definitions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deviceDefinitionPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from deviceDefinition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for device_definitions")
	}

	if len(deviceDefinitionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DeviceDefinition) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDeviceDefinition(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DeviceDefinitionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DeviceDefinitionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), deviceDefinitionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"device_definitions_api\".\"device_definitions\".* FROM \"device_definitions_api\".\"device_definitions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, deviceDefinitionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DeviceDefinitionSlice")
	}

	*o = slice

	return nil
}

// DeviceDefinitionExists checks if the DeviceDefinition row exists.
func DeviceDefinitionExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"device_definitions_api\".\"device_definitions\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if device_definitions exists")
	}

	return exists, nil
}
